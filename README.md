# Отчет по лабораторной работе № 3

---
№ группы: ПМ-2401

Выполнил: Дроздов Иван Юрьевич

Вариант: 11

### Содержание:

- [Постановка задачи](#1-постановка-задачи)
- [Алгоритм](#2-алгоритм)
- [Программа](#3-программа)
- [Тесты](#4-тесты)

### 1. Постановка задачи

> Лото
> 
>Краткое описание
>
>Разработать программу для упрощённой версии игры «Лото». Реализовать функционал создания карточек с наборами чисел, отслеживания прогресса игры, обработки
выпадающих чисел и определения победителя.
>
> Описание функционала
>1. Создание карточки
   Создание карточки с числами от 1 до 100. Карточка может быть задана массивом чисел или набором аргументов фиксированного размера (например, 5 чисел).
   Вывод карточки в формате:
   [1 4 X 19 X]
   , где «X» обозначает закрытые числа.
>2. Подсчёт закрытых и оставшихся чисел
   Функция возвращает количество закрытых чисел и количество оставшихся открытыми чисел на карточке.
>3. Закрытие числа на карточке
   Проверка, есть ли указанное число на карточке. Если число найдено, оно закрывается (заменяется на «X» или -1).
>4. Проверка закрытия всей карточки
   Функция определяет, закрыты ли все числа на карточке. Если все числа закрыты,
   карточка считается полностью закрытой.
>5. Определение выигрыша по массиву чисел
   На вход подаётся массив чисел или число n, за которым следует n чисел. Функция
   определяет, какое из этих чисел позволяет игроку закрыть всю карточку. Если ни
   одно из чисел не закрывает карточку полностью, возвращается -1.
>6. Определение победителя среди нескольких игроков
   Для нескольких игроков (карточек) функция возвращает, кто из них первым закроет карточку, и общее количество игроков, которые смогут закрыть свои карточки

Создадим класс лото, который будет отслеживать и изменять все показатели игры.
Этот класс будет своеобразным менеджером для всей игры. Также создадим класс карточки.
Он нужен для того чтобы взаимодействовать с каждой отдельной карточкой.
Количество игроков будем брать в качестве параметра, а количество карточек у одного игрока возмьем
равным 3.

### 2. Алгоритм

#### Алгоритм выполнения программы:
##### Lotto
###### 1. public Lotto(int countOfPlayers):

Инициализирует объект игры с количеством игроков, переданным в параметре countOfPlayers.
Создается двумерный массив cards, где каждая строка соответствует игроку, а каждый элемент
— это массив, состоящий из 3 карт.

###### 2. public void addCard(int numberOfPlayer):

Добавляет карту для игрока, если это возможно. Проверяет,
что номер игрока корректен и что у игрока еще есть место для карты (не более 3 карт).
Если у игрока уже 3 карты, выводит сообщение об ошибке.

###### 3. public int[][] countClosedAndOpenedNumbers(int numberOfPlayer):

Возвращает массив, в котором для каждой карты игрока (по номеру numberOfPlayer)
указано количество закрытых и открытых номеров.
Для каждой карты вызывается метод countClosedAndOpenedNumbers(),
который возвращает эти данные для конкретной карты.

###### 4. public void closeNumber(int number):

Закрывает указанный номер на всех картах всех игроков.
Для этого метод перебирает все карты и вызывает
метод closeNumber() для каждой из них.

###### 5. public void cardWasClosedCheck(int numberOfPlayer):

Проверяет, были ли закрыты все карты указанного игрока.
Для каждой карты выводится сообщение о том, была ли она закрыта или нет,
с использованием метода cardWasClosedCheck(), который возвращает статус карты.

###### 6. public int[] FindWinnerNumber(int numberOfPlayer, int[] numbersArr):

Определяет, есть ли среди номеров на картах игрока (по номеру numberOfPlayer)
те, которые совпадают с номерами из массива numbersArr.
Для каждой карты вызывается метод FindWinnerNumber(),
который проверяет, соответствует ли номер.

###### 7. public int[] findWinnerPlayer():

Определяет победителя игры среди всех игроков.
Для каждого игрока подсчитывается количество закрытых номеров на его картах,
и если количество закрытых номеров больше, чем у других игроков,
этот игрок становится потенциальным победителем.
Если несколько игроков имеют одинаковое количество закрытых номеров,
то их количество учитывается в массиве winners,
и они могут быть объявлены совместными победителями.

##### Card
###### 1. public Card():

Конструктор, который создает карту с 10 случайными числами от 1 до 100, не повторяющимися на данной карте.

Используется объект Random для генерации случайных чисел.
При каждой генерации проверяется, не существует ли уже такое число на карте (чтобы избежать дубликатов).
Если число уже присутствует, оно генерируется заново. Процесс продолжается до тех пор,
пока не будут заполнены все 10 позиций на карте.

###### 2. public int[] countClosedAndOpenedNumbers():

Возвращает массив из двух элементов: первый — количество закрытых номеров (обозначенных как "X"),
второй — количество открытых номеров. Для каждого числа на карте проверяется, равно ли оно "X".
Если да — увеличивается счетчик закрытых номеров, иначе — открытых.

###### 3. public void closeNumber(int number):

Закрывает указанный номер на карте, заменяя его на символ "X".
Метод перебирает все числа на карте, и если число совпадает с переданным, оно заменяется на "X".

###### 4. public boolean cardWasClosedCheck():

Проверяет, закрыта ли вся карта (то есть все ее числа заменены на "X").
Метод возвращает true, если все числа на карте закрыты (заменены на "X"), иначе — false.

###### 5. public int FindWinnerNumber(int[] numbersArr):

Определяет победный номер, если на карте осталось только одно открытое число,
и оно совпадает с числом из переданного массива numbersArr.
Метод сначала ищет открытое число на карте (то есть не равное "X"), затем проверяет,
есть ли это число в массиве numbersArr.
Если оно есть, это число становится победным, и оно возвращается.

###### 6. @Override public String toString():

Переопределенный метод toString, который возвращает строковое представление карты,
т.е. все 10 чисел, разделенные пробелами и окруженные квадратными скобками.


### 3. Программа
Lotto:
```java
package labs;

public class Lotto {
    private final Card[][] cards; // Двумерный массив карт, где строки — игроки, а столбцы — карты игрока

    // Конструктор для инициализации игры с заданным количеством игроков
    public Lotto(int countOfPlayers) {
        cards = new Card[countOfPlayers][3]; // Каждый игрок может иметь до 3 карт
    }

    // Метод для добавления карты конкретному игроку
    public void addCard(int numberOfPlayer) {
        boolean hasPlace = true;

        // Проверка, что номер игрока корректен
        if (numberOfPlayer - 1 < cards.length && numberOfPlayer - 1 >= 0) {
            // Пытаемся добавить карту для игрока, если есть место
            for (int i = 0; i < cards[numberOfPlayer - 1].length; i++) {
                if (cards[numberOfPlayer - 1][i] == null && hasPlace) {
                    cards[numberOfPlayer - 1][i] = new Card(); // Создаем новую карту
                    hasPlace = false; // Место занято
                }
            }
            // Если место для карты нет, выводим сообщение
            if (hasPlace) {
                System.out.println("Количество карточек уже максимально");
            }
        } else {
            System.out.println("Некорректный номер игрока"); // Сообщение о неправильном номере игрока
        }
    }

    // Метод для подсчета количества закрытых и открытых номеров на картах игрока
    public int[][] countClosedAndOpenedNumbers(int numberOfPlayer) {
        int[][] count = new int[cards[numberOfPlayer - 1].length][2]; // Массив для хранения результатов
        int i = 0;
        // Перебираем карты игрока, если карта существует, получаем информацию о закрытых и открытых номерах
        while (i < cards[numberOfPlayer - 1].length && cards[numberOfPlayer - 1][i] != null) {
            count[i] = cards[numberOfPlayer - 1][i].countClosedAndOpenedNumbers(); // Записываем количество закрытых и открытых номеров
            i++;
        }
        return count; // Возвращаем результат
    }

    // Метод для закрытия конкретного числа на всех картах игры
    public void closeNumber(int number) {
        int j;
        // Перебираем всех игроков и их карты
        for (int i = 0; i < cards.length; i++) {
            j = 0;
            // Перебираем карты игрока, если карта существует, закрываем указанное число
            while (j < cards[i].length && cards[i][j] != null) {
                cards[i][j].closeNumber(number); // Закрываем число на карте
                j++;
            }
        }
    }

    // Метод для проверки, закрыта ли карта игрока
    public void cardWasClosedCheck(int numberOfPlayer) {
        int i = 0;

        // Перебираем карты игрока и проверяем, закрыта ли каждая из них
        while (i < cards[numberOfPlayer - 1].length && cards[numberOfPlayer - 1][i] != null) {
            if (cards[numberOfPlayer - 1][i].cardWasClosedCheck()) { // Проверка, закрыта ли карта
                System.out.println("Карта номер " + (i + 1) + ", " + numberOfPlayer + "-го игрока была закрыта.");
            } else {
                System.out.println("Карта номер " + (i + 1) + ", " + numberOfPlayer + "-го игрока ещё не закрыта.");
            }
            i++;
        }
    }

    // Метод для поиска победного номера для игрока по массиву чисел
    public int[] FindWinnerNumber(int numberOfPlayer, int[] numbersArr) {
        int[] winnerNumbers = new int[cards[numberOfPlayer - 1].length]; // Массив для хранения победных номеров
        int i = 0;

        // Перебираем карты игрока и ищем победные номера
        while (i < cards[numberOfPlayer - 1].length && cards[numberOfPlayer - 1][i] != null) {
            winnerNumbers[i] = cards[numberOfPlayer - 1][i].FindWinnerNumber(numbersArr); // Записываем победный номер
            i++;
        }
        return winnerNumbers; // Возвращаем массив победных номеров
    }

    // Метод для нахождения победителя игры по количеству закрытых номеров
    public int[] findWinnerPlayer() {
        int countOfClosed = -1; // Счетчик для хранения максимального числа закрытых номеров
        int currentCountOfClosed;
        int[] winners = {0, 0}; // Массив для хранения информации о победителях
        int j;

        // Перебираем всех игроков и считаем закрытые номера на их картах
        for (int i = 0; i < cards.length; i++) {
            currentCountOfClosed = 0;
            j = 0;
            // Перебираем карты игрока и суммируем количество закрытых номеров
            while (j < cards[i].length && cards[i][j] != null) {
                currentCountOfClosed += cards[i][j].countClosedAndOpenedNumbers()[0]; // Суммируем количество закрытых номеров
                j++;
            }
            // Если у текущего игрока больше закрытых номеров, он становится победителем
            if (currentCountOfClosed > countOfClosed) {
                countOfClosed = currentCountOfClosed;
                winners[0] = i + 1; // Номер победителя
                winners[1] = 1; // Количество победителей
            } else if (currentCountOfClosed == countOfClosed) {
                winners[1]++; // Если количество закрытых номеров одинаковое, увеличиваем количество победителей
            }
        }

        return winners; // Возвращаем результат с номером победителя и количеством победителей
    }
}
```
Card:
```java
package labs;

import java.util.Random;

public class Card {
    private final String[] numbers = new String[10]; // Массив для хранения 10 случайных чисел на карточке

    // Конструктор, генерирующий 10 уникальных случайных чисел для карты
    public Card() {
        Random random = new Random(); // Создаем объект для генерации случайных чисел
        boolean hasDuplicate; // Переменная для проверки уникальности чисел
        int index = 0; // Индекс для вставки чисел
        int x; // Переменная для хранения случайного числа

        // Генерация чисел до тех пор, пока не заполним массив
        while (index < 10) {
            x = random.nextInt(100) + 1; // Генерация случайного числа от 1 до 100
            hasDuplicate = false;
            // Проверка, нет ли дублирующегося числа в массиве
            for (int i = 0; i < index; i++) {
                if (String.valueOf(x).equals(this.numbers[i])) {
                    hasDuplicate = true;
                }
            }
            // Если число уникальное, добавляем его в массив
            if (!hasDuplicate) {
                this.numbers[index] = String.valueOf(x);
                index++;
            }
        }
    }

    // Метод для подсчета количества закрытых ("X") и открытых номеров на карте
    public int[] countClosedAndOpenedNumbers() {
        int[] count = {0, 0}; // Массив, где [0] — количество закрытых, [1] — количество открытых
        for (int i = 0; i < numbers.length; i++) {
            if (numbers[i].equals("X")) {
                count[0]++; // Увеличиваем счетчик закрытых номеров
            } else {
                count[1]++; // Увеличиваем счетчик открытых номеров
            }
        }
        return count; // Возвращаем массив с подсчитанными значениями
    }

    // Метод для закрытия конкретного числа на карте
    public void closeNumber(int number) {
        for (int i = 0; i < numbers.length; i++) {
            if (String.valueOf(number).equals(numbers[i])) {
                numbers[i] = "X"; // Закрываем число, заменяя его на "X"
            }
        }
    }

    // Метод для проверки, закрыта ли вся карта (все числа заменены на "X")
    public boolean cardWasClosedCheck() {
        boolean cardIsClosed = true; // По умолчанию предполагаем, что карта закрыта
        for (int i = 0; i < numbers.length; i++) {
            if (!numbers[i].equals("X")) { // Если хоть одно число не закрыто
                cardIsClosed = false; // Карта не закрыта
            }
        }
        return cardIsClosed; // Возвращаем результат
    }

    // Метод для поиска победного номера на карте (если номер присутствует в массиве)
    public int FindWinnerNumber(int[] numbersArr) {
        int winnerNumber = -1; // По умолчанию победного номера нет
        int indexOfRequiredNumber = -1; // Индекс первого открытого номера на карте

        // Находим первый открытый номер на карте
        for (int i = 0; i < numbers.length; i++) {
            if (!numbers[i].equals("X")) {
                if (indexOfRequiredNumber == -1) {
                    indexOfRequiredNumber = i; // Запоминаем индекс первого открытого числа
                }
            }
        }

        // Если нашли открытый номер, ищем его в массиве чисел
        if (indexOfRequiredNumber != -1) {
            for (int i = 0; i < numbersArr.length; i++) {
                // Если число из массива совпадает с открытым номером на карте, это победный номер
                if (String.valueOf(numbersArr[i]).equals(numbers[indexOfRequiredNumber])) {
                    winnerNumber = numbersArr[i]; // Устанавливаем победный номер
                }
            }
        }

        return winnerNumber; // Возвращаем найденный победный номер или -1, если его нет
    }

    // Переопределенный метод toString для представления карты в строковом виде
    @Override
    public String toString() {
        String s = "[ ";

        for (int i = 0; i < numbers.length; i++)
            s += numbers[i] + " "; // Добавляем каждое число карты в строку

        return s + "]"; // Возвращаем строку с числами карты
    }
}
```
### 4. Тесты

#### Тест 1: Добавление карт:

Проверяет метод addCard() для добавления карт игрокам.
Важно проверить, что происходит, когда попытаться добавить больше 3 карт для игрока
и когда добавляются карты для нескольких игроков.

#### Тест 2: Подсчет закрытых и открытых номеров:

Проверяет метод countClosedAndOpenedNumbers() для подсчета закрытых и открытых номеров на картах игрока.

#### Тест 3: Закрытие номеров:

Проверяет метод closeNumber() для закрытия числа на всех картах.
Затем снова проверяется количество закрытых и открытых номеров,
чтобы убедиться, что изменения применены.

#### Тест 4: Проверка закрытия карт:

Проверяет метод cardWasClosedCheck() для игроков, чтобы убедиться,
что он выводит правильную информацию о том, закрыта ли карта.

#### Тест 5: Поиск победного номера:

Проверяет метод FindWinnerNumber(). В тесте используется массив чисел, и мы проверяем,
какие из них совпадают с номерами на картах игрока.

#### Тест 6: Поиск победителя игры:

Проверяет метод findWinnerPlayer(). Считается,
сколько закрытых номеров у каждого игрока, и определяется победитель.
